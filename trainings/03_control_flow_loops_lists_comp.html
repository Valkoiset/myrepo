<!DOCTYPE html>
<html>
  <head>
    <title>Control flow, loops, and list comprehension</title>
    <meta charset="utf-8">
    <meta name="author" content="Mercer 2018" />
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link rel="stylesheet" href="css\idash.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Control flow, loops, and list comprehension
### Mercer 2018

---


class: inverse, middle, center
#Control flow

---
##if-elif-else statment
if-elif-else statments are used to change the code's behaviour based on some conditions it might encounter. Basic formula for this 
statements looks as follows:

```
if condition_1:
    code to be executed if condition_1 is met
elif condition_2:
    code to be executed if condition_2 is met
...    
elif condition_n:
    code to be executed if condition_n is met
else:
    code to be executed if no other condition is met
```
Conditions are evaluated from the top to the bottom. If one of them is met the rest is not evaluated.

---
##if-elif-else


```python
number = 3
if number % 2 == 0:
    print('This number is even.')
else:
    print('This number is odd.')
# This number is odd.
```

---
class:inverse
###Exercise 1 (5 min)
Write a script, which based on two variables:
- `user_name` (can be any string),
- `time_of_day` (can be 'morning', 'afternoon', or any other string)

will create one of the following greetings:
- "Good morning John, you are an early bird!" (user_name = 'John', time_of_day = 'early morning')
- "Good morning Alice, punctual as always!" (user_name = 'Alice', time_of_day = 'morning')
- "Good morning John, better late than never, right?"(user_name = 'John', time_of_day = 'late morning')
- "Hello Alice, your time of arrival is kind of strange." (user_name = 'Alice', time_of_day is some other string)

???
user_name = 'Luke'
time_of_day = 'sda'

if time_of_day == 'early morning':
    print(f"Good morning {user_name}, you are an early bird!")
elif time_of_day == 'morning':
    print(f"Good evening {user_name}, punctual as always!")    
elif time_of_day == 'late morning':
    print(f"Good evening {user_name}, better late than never, right?")    
else:
    print(f"Hello {user_name}, your time of arrival is kind of strange.")

---
class: inverse
###Exercise 2 (10 minutes)
You write a script that will calculate the final price of an order in your online shop. Based on a total price of an order your code should:
1. Deduct 5% from the order's value for regular customers. Regular customers have a free delivery, but you should still check if delivery option value is correctly specified (see the next point), and if not react accordingly.
2. Based on the selected delivery option add 10 for economic delivery or 20 for priority delivery for non-regular customers. If delivery option is neither of those two options you should print 'Delivery option not properly specified.' and set total to None.

---
class: inverse

####Inputs:

- total: int, total value of an order
- delivery_option: string, 'economic', 'priority' or any other value
- regular_customer: bool

####Outputs:
```
regular_customer = True
delivery_option = 'economic'
total = 100 
# should return 95

regular_customer = True
delivery_option = 'priority'
total = 100 
# should return 95
```
---
class: inverse
```
regular_customer = True
delivery_option = 'priorityd'
total = 100 
# should return 95

regular_customer = False
delivery_option = 'economic'
total = 110 
# should return 95

regular_customer = False
delivery_option = 'priority'
total = 100 
# should return 120
```

???
regular_customer = False
delivery_option = 'economicd'
total = 100 

if regular_customer:
    total *= .95
    if delivery_option not in ['economic', 'priority']:
        total = None
        print('Delivery option not properly specified.')
else:
    if delivery_option == 'economic':
        total += 10
    elif delivery_option == 'priority':
        total += 20
    else:
        total = None
        print('Delivery option not properly specified.')

print(total)

---
class: inverse, center, middle

# Loops
---
## Loops
In programming loops are used to iterate over a sequence of elements and do something with each element.

--

For example we might want to go through a list of numbers and multiply each one of them by 100, or go through the list of strings and remove not needed whitespace from each of them.

--

In Python we have two types of loops:
- while loops,
- for loops.

---
## While loop
- Do something until some condition is met.
- Usually, there is some sort of index that is incremented at each run of the loop.
- Rarely used in Python.

--

```python
todo_list = ['grocery', 'washing', 'dishes']
i = 0
while i &lt; len(todo_list):
    print(todo_list[i])
    i += 1
# grocery
# washing
# dishes
```

It is important to specify the condition that will end the loop's execution, because without it, it will go on forever.

---
## For loops
- Do something X number of times.
- In the example below we are iterating over the indexes of the object. Usually, it is better to do it over elements of the object itself.

--
.small-code[

```python
for i in range(len(todo_list)):
        print(todo_list[i])
```
]

--

`range()` function in the example above generates the sequence of numbers up to but not including the specified number. Here we generate numbers from 0 to the length of our todo_list.

--
.small-code[

```python
len(todo_list)
# 3
list(range(3))
# [0, 1, 2]
```
]

---
## For (each) loop

- Do something with every element in the set,
- Usually maintains no explicit counter.
- Most common in Python.

--

```python
for item in todo_list:
    print(item)
```

---
class:inverse
###Excercise 3 (3 min)

Write a loop that prints integers from one to 10, one by one.

???
for integ in range(1,11):
    print(integ)

---
## What if we need index?

`enumerate()` function returns a tuple with a pair of values - a __counter__ and the __value__ yielded by iterable argument.
--

```python
for item in enumerate(todo_list):
    print(item)
# (0, 'grocery')
# (1, 'washing')
# (2, 'dishes')
```

--

```python
for index, what_to_do in enumerate(todo_list, start=1):
    print(f'{index}. {what_to_do}')
# 1. grocery
# 2. washing
# 3. dishes
```

---
class:inverse
###Excercise 4 (5 min)
Someone messed up and created a list that ranks programming languages in reversed order. Write a loop which prints a programing language with it's respective position in correct order.

.small-code[

```python
top_languages = ['C++', 'Java', 'Python', 'Swift', 'JavaScript']
```
]
???
for position, language in enumerate(reversed(top_languages), start=1):
    print(f'{position}. {language}')

---
##What if we have two lists?

`zip()` function returns tuples with corresponding elements from both sequences. It continues until the __shortest__ iterable in the argument sequence is exhausted.

--
.small-code[

```python
names = ['mike', 'john', 'jerry']
occupations = ['plumber', 'woodsman', 'data scientist']
for n in zip(names, occupations):
    print(n)
# ('mike', 'plumber')
# ('john', 'woodsman')
# ('jerry', 'data scientist')
```
]
---
##What if we have two lists?
We can use it, for example, to create sentence using words from two lists.


```python
for name, occupation in zip(names, occupations):
    print(f'{name} is {occupation}')
# mike is plumber
# john is woodsman
# jerry is data scientist
```


---
class:inverse
###Excercise 5 (15 min)
You have two list - test and control. Write a loop which will go through test list and verify if coresponding element in control is the same. If not, add index of wrong value to errors list. Try to avoid looping just through indexes.


```python
test = [2, 6, 8, 3, 1, 5, 7, 12, 9, 4]
control = [2, 5, 8, 3, 3, 5, 7, 2, 6, 1]
```
???
errors = []
for n, (x, y) in enumerate(zip(test,control)):
    if x!=y:
        errors.append(n)
print(errors)
    
---
##What if we have two lists of different length?

`zip_longest()` works as `zip()` with the exception that it runs until the end of the longest sequence. Missing values from the shorter sequence are set to `None`.

.small-code[

```python
names = ['mike', 'john', 'jerry', 'steven']
occupations = ['plumber', 'woodsman', 'data scientist']
```
]

--
.small-code[

```python
from itertools import zip_longest
for name, occupation in zip_longest(names, occupations, ):
    print(f"{name} is {occupation if occupation else 'unemployed'}")
# mike is plumber
# john is woodsman
# jerry is data scientist
# steven is unemployed
```
]
---
##Things to remember:
1. Often you don't need index - you can leverage Python ability to loop over objects.
2. If you need the index, use `enumerate` function.
3. In case of two or more lists, `zip` or `zip_longest` are helpful.

---
class: center, middle, inverse

# List comprehension
---
## How to square each element of a list?
Let's assume that we have a list of numbers and we want to square them. How could we do it?


```python
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```
---
class: inverse
##Exercise 6 (5 minutes)
Write a loop that will square numbers from the list.


```python
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

???
result = []
for number in numbers:
    result.append(number ** 2)
result
---
##List comprehension
A loop does it's job but it is a lot of repetetive code to write. A more compact solution to this kind of problems is a mechanism called &lt;b&gt;list comprehension&lt;/b&gt;. It allows us to build a sequence using some other sequence.


```python
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
[number ** 2 for number in numbers]
# [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
```

---
##List comprehension
List comprehension's code is easiest to understand from the end to the beginning. It consists of three elements:
- an input sequence &lt;code&gt;[number ** 2 for number in &lt;b&gt;numbers&lt;/b&gt;]&lt;/code&gt;
- a variable &lt;code&gt;[number ** 2 for &lt;b&gt;number&lt;/b&gt; in numbers]&lt;/code&gt;
- an output expression &lt;code&gt;[&lt;b&gt;number ** 2&lt;/b&gt; for number in numbers]&lt;/code&gt;

---
class: inverse
###Exercise 7 (5 minutes)
Create a new list with the length of each word from the list `word`.


```python
words = ['car', 'bicycle', 'house', 'tank']
```

???
[len(word) for word in words]

---
##Map function
An alternative way to apply function to every element of the list is a `map()` function.


```python
ls = [1,2,3,4]
map(lambda x: x**2, ls)
# &lt;map at 0x107735358&gt;
```

`map()` returns iterator. You can use `list()` to get the values.


```python
list(map(lambda x: x**2, ls))
# [1, 4, 9, 16]
```
---
## How to square only even elements of the list?
Let's suppose we want to square only even numbers from our list of numbers. How could try to solve this problem?


```python
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

---
class: inverse
###Exercise 8 (5 minutes)
Write a loop that will square only even numbers in the list. 


```python
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

???
result = []
for number in numbers:
    if number % 2 == 0:
        result.append(number ** 2)
result

---
##List comprehension with a condition
Loops with a condition are even more lenghty. Fortunately, we can extend our list comprehension statement to include the condition.


```python
[number ** 2 for number in numbers if number % 2 == 0]
# [4, 16, 36, 64, 100]
```

---
## Using list comprehension to remove elements
We have seen earlier `remove()` method, that can be used to remove the specific object from the list. It's limitation is that it removes only the first occurence of a given object. 


```python
names = ['Alice', 'John', 'Bruce', 'Bob', 'Alice']
names.remove('Alice'); names
# ['John', 'Bruce', 'Bob', 'Alice']
```

We can use list comprehension to remove all instances of the same object from the list.


```python
names_list = ['Alice', 'John', 'Bruce', 'Bob', 'Alice']
[name for name in names_list if name != 'Alice']
# ['John', 'Bruce', 'Bob']
```
---
class: inverse
###Exercise 9 (5 minutes)
Calculate the number of occurences of letter 'a' in the words that have more than 4 characters.

.small-code[

```python
words = ['car', 'bicycle', 'house', 'tank', 'keyboard', 'cataclysm']
```
]

???
[word.count('a') for word in words if len(word) &gt; 4]
---
##Filter and map combination
We also have an alternative here. We could use `filter()` function to get the elements that we want, and then use `map()` function on them to perform the calculation.

.small-code[

```python
ls = [1,2,3,4]
list(filter(lambda x: x % 2 == 0, ls))
# [2, 4]
```
]

Filter also returns an iterator, so it is wrapped by list function here.

.small-code[

```python
list(map(lambda x: x**2, filter(lambda x: x % 2 == 0, ls)))
# [4, 16]
```
]

It gets unreadable quickly, so it might be better to stick with list comprehension.
---
##How to multiply each element of one list by each element of the second list?
Imagine now, that instead of one list we have two lists:


```python
list_1 = [2, 3, 4]
list_2 = [5, 6, 7]
```

We would like to multiply each element of the first list by each element of the second one. So we want to get [10, 12, 14, 15, 18, 21, 20, 24, 28]. How can we do it?

---
class: inverse
###Exercise 10 (5 min)
Multiply each element of one list by each element of the second list.

Hint: use nested loops.

???
results = []
for l1 in list_1:
    for l2 in list_2:
        results.append(l1 * l2)
results
---
##Nested loops in list comprehension
Nested loops, especially in the more complicated examples, are pretty lenghty and hard to understand. However, a list comprehension can help us here as well, as it can replicate them in just one line.


```python
[l1 * l2 for l1 in list_1 for l2 in list_2]
# [10, 12, 14, 15, 18, 21, 20, 24, 28]
```

---
## Map with two iterables
We could also consider using `map()` to try to replicate nested loops. However, it behaves differently than the list comprehension, as it applies function to corresponding elements of each list, instead of every combination.


```python
list_1 = [2, 3, 4]
list_2 = [5, 6, 7]
list(map(lambda x, y: x * y, list_1, list_2))
# [10, 18, 28]
```

---
class: inverse, center, middle

#Dictionary comprehension

---
##Dictionary comprehension
There is analogous mechanism to a list comprehension for creating dictionaries. Unsuprisngly, it is called &lt;b&gt;dictionary comprehension&lt;/b&gt;.

.small-code[

```python
words = ['car', 'bicycle', 'house', 'tank', 'keyboard', 'cataclysm']
{word:len(word) for word in words}
# {'bicycle': 7, 'car': 3, 'cataclysm': 9, 
#  'house': 5, 'keyboard': 8, 'tank': 4}
```


```python
words = ['car', 'bicycle', 'house', 'tank', 'keyboard', 'cataclysm']
new_dict = {word:len(word) for word in words if word.count('a') &gt;= 1}
new_dict
# {'car': 3, 'cataclysm': 9, 'keyboard': 8, 'tank': 4}
```


```python
{i:j for i, j in enumerate(new_dict)} # switch keys with values
# {0: 'car', 1: 'tank', 2: 'keyboard', 3: 'cataclysm'}
```
]
---
class: inverse 
###Exercise 11 (5 minutes)
Given a list of character names, prepare a dictionary with their intials as the key and their full name as the value. 

.small-code[

```python
characters = ['Jon Snow', 'Theon Greyjoy', 'Tyrion Lannister', 
              'Arya Stark', 'Petyr Baelish']
```
]
???
{character.split(' ')[0][0] + character.split(' ')[1][0]:character for character in characters}

---
class: inverse, bottom, center
background-image: url('www/img/logo_white.png')
background-size: 50%

mb@idash.pl mo@idash.pl
    </textarea>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"ratio": "16:9",
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function() {
  var d = document, s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})();</script>

<script>
(function() {
  var i, text, code, codes = document.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
})();
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
