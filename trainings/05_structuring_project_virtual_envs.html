<!DOCTYPE html>
<html>
  <head>
    <title>Structuring Python project, and virtual environments</title>
    <meta charset="utf-8">
    <meta name="author" content="Mercer 2018" />
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link rel="stylesheet" href="css\idash.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Structuring Python project, and virtual environments
### Mercer 2018

---


class: inverse, center, middle


# Structuring Python project

---
## Modular programming

 Modular programming refers to the __process of breaking__ a large, unwieldy programming __task__ into separate, smaller, __more manageable subtasks or modules__. Individual modules can then be then combined together like building blocks to create a larger application. &lt;br&gt;&lt;br&gt;

---
## Advantages of modular programming

- __Simplicity__ - rather than focusing on the entire problem at hand, a module typically focuses on one relatively small portion of the problem.

--

- __Maintainability__ - modules are usually designed to enforce __logical boundaries__ between different problem domains. If modules are written in a way that __minimizes interdependency__, there is decreased likelihood that modifications to a single module will have an impact on other parts of the program. This makes it more viable for a team of many programmers to __work collaboratively__ on a large application.

---
## Advantages of modular programming
- __Reusability__ - functionality defined in a single module can be easily reused by other parts of the application, which in turn eliminates the need to recreate duplicate code.

--

- __Scoping__ - modules typically define a separate namespace, which helps avoid collisions between identifiers in different areas of a program. 

---
## Module vs package

A Python __module__ is a __file__ with a __.py extension__, and a Python __package__ is any __folder__ that has __modules inside it__ (or, in Python 2, a folder that contains an `__init__.py` file).

---
##Importing built-in modules and packages
You can extend Python functionality by importing modules and packages, that contain addtional functions that can be useful for solving specific problems. There are several built-in modules, and you can install hundreds of additional. You can import a module or a package using the `import` statement.

By convention, `import` statements are declared at the top of the script.
---
##Importing modules and packages
- import the whole module/package:


```python
import math
math.sqrt(4)
```

--
- import the whole module/package, give it a shorter name:


```python
import math as m
m.sqrt(4)
```

---
##Importing built-in modules
- import just one function from the module/package:


```python
from math import sqrt
sqrt(4)
```

--
- import all functions from the module/package (not recommended):


```python
from math import *
sqrt(4)
```
---
##Installing packages
If a given package is not installed on your machine, you can do it by using either `pip install module_name` or `conda install module_name` commands in your command line, depending on what package manager you use. Once the package is installed, you will be able to import it.

---

## Importing your own modules
It is a good programming practice to keep your functions in seperate modules. You can import functions from a module located in your working directory using the same the `import` keyword.
 
--


```python
import hello_world
hello_world.hello_world()
```
--

All the same syntax applies here:


```python
from hello_world import hello_world
hello_world()
```

--

```python
from hello_world import *
hello_world()
```
---
## What happens when the import statement is being executed?
When the interpreter executes import statement, it searches for `hello_world.py` in a list of directories assembled from the following sources:
 
- directory from which the input script was run or the current directory if the interpreter is being run interactively,
- list of directories contained in the PYTHONPATH environment variable, if it is set,
- an installation-dependent list of directories configured at the time Python is installed.

---
## What happens when the import statement is being executed?
After the import, you can check the location where the module was found with the module's `__file__` attribute:

--

```python
hello_world.__file__
```

---
### Importing your own modules from folders inside your working directory
The previous code assumed that the module you wanted to import was in your working directory. To import the module that is stored in the folder in your working directory, you need to put the name of that folder before the module name seperating the two with a dot (`.`).

--

```python
from modules.my_math import add, multiply
add(1, 2)
multiply(3, 6)
```
---
## Importing your own modules located in other directories
If you would like to import module from folders outside of your working director, you can add it `sys.path`.

--
.small-code[

```python
import sys
sys.path.insert(0, 'C:\\Users\\dell\\Documents\\another_module\\')
sys.path
```
]

--

.small-code[

```python
import print_greeting 
print_greeting.print_greeting()
print_greeting.__file__
```
]

---
## Requirements

You should always include in your project list of packages that are needed to run it. Customarily it takes a form of `requirements.txt` file, with list of packages. It could look as follows:

--
```text
numpy
pandas
python-dateutil
pytz
six
```

---
## Requirements
It is sometimes also useful to add information on versions of packages that were used in development:

--

```text
numpy&gt;=1.15.2
pandas==0.23.4
python-dateutil==2.7.3
pytz==2018.5
six==1.11.0
```

---
## Requirements
You can automatically create requirements file containing list of packages in you environment by using pip freeze:

--
```zsh
$ pip freeze &gt; requirements.txt
```
--
The advantage of specifing requirements file is that other users or your future self will be able to set up their environment easily by running:

--
 ```zsh
 $ pip install -r requirements.txt
 ```
--
Pip will install either specified or newest versions of packages listed in the file saving the trouble of manually installing all the dependencies.

---
## Requirements
The same could be done in conda using:

```zsh
conda list -e &gt; requirements.txt
```

to save requirements file, and:


```zsh
conda install --yes --file requirements.txt
```

to install packages from the requirements file.

---
class: inverse, center, middle


# Virtual Environments

---
## System vs site packages

As it was mentioned previously you can extend Python's functionality with packages. There are two types of packages:

- __system packages__ are packages that are part of the __standard Python library__, 
- __site packages__ are __third party__ libraries.

---
## System packages

Most system packages are stored in a child directory of the path stored in sys.prefix. To find this location you can use following code:

--


```python
import sys
sys.prefix
```

---
## Site packages
Site packages are typically placed in one of the directories pointed to by site.getsitepackages:

--
  

```python
import site
site.getsitepackages()
```

---
## Creating separate environment
By default, __every project__ on your system will __use same directories__ to store and retrieve __site packages__ (third party libraries), therefore will use same versions of those packages.
The main purpose of Python virtual environments is to create an __isolated environment__ for Python projects. This means that __each project__ can have its __own dependencies__, regardless of what dependencies every other project has (i.e. it can use different version of packages than default system versions). &lt;br&gt;&lt;br&gt;

--
You can create virtual environment in a directory with: 

```bash
$ python -m venv env
```
---
## Creating separate environment
Previous command creates a directory called `env`, which contains three folders:
- __Include__ that contains C headers that compile the Python packages.
- __Scripts (bin in linux)__ consists of files that interact with the virtual environment.
- __Lib__ contains a copy of the Python version along with a site-packages folder where each dependency is installed.

---
## Activating the virtual environment
To use this isolated virtual environment, you need to "activate" it. 

--
```bash
$ env\Scripts\activate.bat
(env) $
```
--
Notice that, after activation, your prompt is now prefixed with name of virtual environment - an indicator that "env" is currently active. This implies that the Python executable will only use this environment's packages and settings. &lt;br&gt;&lt;br&gt;

---
## Deactivating the virtual environment
To exit virtual environment use:

--
```bash
$ deactivate
```

Notice that you prompt no longer has any prefix, which indicates that Python executable will use system default packages and
settings.

---
## Checking the location of Python executable
You can check out the locations of the different Python executables by using:

--
```bash
$ where python
```

 If you run above command in your virtual environment, it's Scripts directory will be in path. That means that Python and packages stored there are used instead of system-wide versions. The other path in results will indicate your system-wide Python directory. &lt;br&gt;&lt;br&gt;

---
## Directory locations
 There is no difference between system-wide and virtual environment's Pythons. What matters, are their __directory locations__. When Python is starting up, it looks at the path of its binary. It then sets the location of sys.prefix and sys.exec_prefix based on this location, omitting the Script portion of the path.

 The path located in sys.prefix is then used for locating the site-packages directory by searching the relative path lib/site-packages/.

---
class:inverse

 ## Excercise (15 min)
 
 
 1. Create a new virtual environment "test_env".
 2. Activate it.
 3. Check the location of site packages of that environment.
 4. Check which Python executable it is using.
 5. Deactivate environment.
 6. Check where your Python system-wide executable is located.
 7. Verify that you have numpy installed (or install it using pip install numpy).
 8. Check if you have numpy in your virtual environment.

???
1. python -m venv test_env
2. test_env\Scripts\activate.bat
3-4. where python
5. deactivate
6. where python
7. python; import numpy as np
8. test_env\Scripts\activate.bat; python; import numpy as np

---
## Virtual environments in Anaconda
Anaconda offers it's own virtual environment mangement system. You can create conda's virtual environment:

```bash
conda create --name my_env python=3.5
```

Note that we can also specify the version of the Python we want to use, but it is optional. You can use:

```bash
activate my_env
deactivate
```

to activate and deactivate the environment.

---
class: inverse, middle, center
#Git

---
## Git intro

Git is a distributed version control system (DVCS).

A __version control system (VCS)__ is a set of tools that __track the history__ of a set of files. This means that you can __save the state__ of your files at any point. Then, you may continue to edit those files and store that state as well. It works similary to creating a __backup copy__ of your working directory. Saving the state is known as making a `commit`. The collection of `commits` is called a `repository`. 

---
## How to create a repository?
To create a `repository` you can either intialize it localy using:

--
``` zsh
$ git init
```
--
or `clone` a remote repository:

--
``` zsh
$ git clone &lt;repo_url&gt;
```
---
## git status
 You can get some information about the repository using:

--
 ``` zsh
 $ git status
 ```
--
This shows you information on:
- which branch you are using,
- which files have changed,
- if any files are staged,
- are there any untracked files.
 
---
## git add
When you add the new file to the repo it is showed as `untracked`, which means that the file is not part of the repo and is not under version control. You can fix that by adding the file to Git with the following command:

--
 ``` zsh
 $ git add &lt;file_name&gt;
 ```
 
--
or you can add all untracted files to the repo using:

--
 ``` zsh
 $ git add .
 ```
---
## git reset
`git reset` is used to unstage a given file:

 ``` zsh
 $ git reset file_name
 ```

---
## git commit
Adding the file to Git moves it into the staging area, which means it can be commited to the repo. When you commit changes, you are telling Git to make a snapshot of the repo's state.

--
 ``` zsh
 $ git commit -m "Initial commit"
 ```
--
You can add message to the commit informing about it's content or the nature of applied changes using the -m option.

---
## git pull / git push
When working with the remote directory, you will need two additional git commands:

--
 ``` zsh
 $ git pull
 ```
--
It allows you to merge newest changes from the remote repo into your local repo, while with:

--
 ``` zsh
 $ git push
 ```
--
you are sending your local changes to the remote repo.

---

class: inverse, bottom, center
background-image: url('www/img/logo_white.png')
background-size: 50%

mb@idash.pl mo@idash.pl
    </textarea>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"ratio": "16:9",
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function() {
  var d = document, s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})();</script>

<script>
(function() {
  var i, text, code, codes = document.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
})();
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
