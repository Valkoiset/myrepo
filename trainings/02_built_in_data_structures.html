<!DOCTYPE html>
<html>
  <head>
    <title>Built-in data structures</title>
    <meta charset="utf-8">
    <meta name="author" content="Mercer 2018" />
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link rel="stylesheet" href="css/idash.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Built-in data structures
### Mercer 2018

---


class: inverse, center, middle
#Tuple
---
##Tuple

- A tuple is a fixed-length, immutable sequence of Python objects,
- You can create it by separating Python objects with a comma...


```python
my_tuple = 1, 2, 3
my_tuple
# (1, 2, 3)
```
--
- ... or by putting Python objects into the parenthesis


```python
my_tuple_alt = (1, 2, 3)
my_tuple_alt
# (1, 2, 3)
```
---
##Tuple
A tuple created with parenthesis is the same as a tuple created without it.


```python
my_tuple = 1, 2, 3
my_tuple_alt = (1, 2, 3)
my_tuple == my_tuple_alt
# True
```
---
##Tuple
Using parenthesis when creating a tuple is useful for more complicated expressions, like a tuple of tuples.


```python
my_tuple_nested = (4, 5, 6), (7, 8)
my_tuple_nested
# ((4, 5, 6), (7, 8))
```
---
## Tuple is fixed-length
You can't change the size of a tuple. There are no methods that you could use to append new objects to it or remove objects that it already stores.

---
##Tuple is immutable
After tuple is created you can't modify objects that it stores*.


```python
my_tuple = ([1, 2, 3], 'a', 1)
tuple_from_string[2] = 'a'
# TypeError: 'tuple' object does not support item assignment
```
--
Unless the object is itself mutable.

---
## Exception to tuples immutability
Objects that are mutable themselves, like lists, can be changed inside a tuple.


```python
my_tuple = ([1,2,3], 'a', 1)
my_tuple
# ([1, 2, 3], 'a', 1)
```


```python
my_tuple[0].append(4)
my_tuple
# ([1, 2, 3, 4], 'a', 1)
```

---
##Tuple is a sequence of Python objects
Tuples can store different Python objects like lists, other tuples, strings, and numerics types.


```python
((1, 2), [5, 10], 'some_name', 1, 5.5)
# ((1, 2), [5, 10], 'some_name', 1, 5.5)
```
---
##Converting other objects into tuples
You can convert any sequence or iterator into tuple using `tuple` function.


```python
tuple([1, 2, 3]) # list into tuple
# (1, 2, 3)
```


```python
tuple(range(10)) # range object into tuple
# (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
```


```python
tuple('string') # string into tuple
# ('s', 't', 'r', 'i', 'n', 'g')
```

---
##Accessing elements of a tuple
As with most other sequence types in Python, you can access elements of the tuple using square brackets notation ([ ]) with an index of element you want.


```python
tuple_from_string = tuple('string')
tuple_from_string[0]
# 's'
```

--
Keep in mind that in Python indexes start from 0, so the element with an index 1 is actually the second element in the sequence.


```python
tuple_from_string[1]
# 't'
```
---
##Slicing more than one value
You can extract more than one element from the tuple by specifing the first and the last element you are interested in.


```python
tuple_from_string = tuple('string')
tuple_from_string[1:3]
# ('t', 'r')
```

--
Note that the second number means &lt;i&gt;up to the index but not including it&lt;/i&gt;.

---
##Slicing relative to the end
A negative sign before the index means that we want to take an object on a given position relative to the end of a sequence.


```python
tuple_from_string = tuple('string')
tuple_from_string[-1] # get the last element of the tuple
# 'g'
```
--

```python
tuple_from_string[-4:-2]
# ('r', 'i')
```

---
##Slicing more than one value with a step
In slicing, you can specify step by adding another integer after the comma. It is used when you want to extract every n element from the tuple. If you do not specify it, it is set to 1 as default.


```python
tuple_from_string = tuple('string')
tuple_from_string[0:3:2]
# ('s', 'r')
```

--
If you omit the beginning and/or ending index, you will get the whole length of an object in that direction.


```python
tuple_from_string[::2]
# ('s', 'r', 'n')
```

---
##Slicing a sequence backwards
You can also go through the tuple from the last element to the first by setting step as a negative value.


```python
tuple_from_string = tuple('string')
tuple_from_string[4:0:-1]
# ('n', 'i', 'r', 't')
```

---
class:inverse
###Exercise 1 (5 minutes)
Convert strings below to tuples. Check which of them are palindromes.

Palindrome is a sequence of characters which reads the same backward as forward.


```python
strings = "redivider, deified, eodermdrome"
```
???
str_1, str_2, str_3 = strings.split(', ')

str_1_t = tuple(str_1)
str_1_tr = str_1_t[::-1]
str_1_t == str_1_tr

str_2_t = tuple(str_2)
str_2_tr = str_2_t[::-1]
str_2_t == str_2_tr

str_3_t = tuple(str_3)
str_3_tr = str_3_t[::-1]
str_3_t == str_3_tr

---
##Unpacking tuples
You can assign variables to a tuple to unpack it.


```python
my_tuple = (1, [1, 2], 'a')
my_tuple
# (1, [1, 2], 'a')
```


```python
a, b, c = my_tuple
```


```python
a # 1
b # [1, 2]
c # 'a'
```

---
##Tuples unpacking in function's return
Tuples unpacking is useful when you want to return more than one object from a function.


```python
def do_calculations(x, y):
    multiplication = x * y
    addition = x + y
    return multiplication, addition 
do_calculations(10, 5)
# (50, 15)
```


```python
res_1, res_2 = do_calculations(10, 5)
res_1 # 50
res_2 # 15
```

---
##Using tuples unpacking to swap values
You can also use the unpacking mechanism of tuples to change variables' names.


```python
a = 1
b = 2
a, b = b, a
a # 2
b # 1
```

---
class: inverse
###Exercise 2 (5 minutes)

Use tuples unpacking to get `a = 15, b = 6, c = 10` from `a = 6, b = 10, c = 15`.

???
b, a = a, b
c, a = a, c
a, b, c

---
##Using tuple unpacking in iterations
Variable unpacking is also used when iterating over more than one object.


```python
seq = [(1, 2), (3, 4), (5, 6)]
for a, b in seq:
    print(f'a = {a}, b = {b}')
# a = 1, b = 2
# a = 3, b = 4
# a = 5, b = 6    
```
---
##Tuple unpacking with \*&lt;i&gt;name&lt;/i&gt; syntax
You can unpack more than one object from the tuple using *&lt;i&gt;name&lt;/i&gt; syntax.


```python
vals = 1, 2, 3, 4
a, b, *rest = vals
rest # [3, 4]
```

--
Note that objects in the *rest part are put into a list.

---
##Tuple unpacking with \*&lt;i&gt;name&lt;/i&gt; syntax
Conventionally, elements of a tuple that are not needed are assigned into *_ variable.


```python
vals = 1, 2, 3, 4
a, b, *_ = vals
```

---
class: inverse, middle, center
#List

---
##List

- A list is a variable-length, mutable sequence of Python objects.
- We can create it using square brackets.


```python
my_list = [2, 3, 4]
my_list
# [2, 3, 4]
```

- As tuples, lists can also store other sequence, and also numeric types.


```python
[1, 'a', [1, 2, 3], (1, 2, 3)]
# [1, 'a', [1, 2, 3], (1, 2, 3)]
```
---
##List
Python objects can be converted into lists using `list` function.


```python
list((1,2,3))
# [1, 2, 3]
```


```python
list('ala')
# ['a', 'l', 'a']
```


```python
list(range(5))
# [0, 1, 2, 3, 4]
```

---
##Adding elements to lists
One of the things that diferentiates lists from tuples is that lists are variable-length objects. This means that you can add new elements to a list or remove existing ones. We have two methods for adding new elements to a list:

- &lt;b&gt;list.append(x)&lt;/b&gt; puts x item at the end of a list.


```python
my_list = [1, 2, 3, 4]
my_list.append(5)
my_list
# [1, 2, 3, 4, 5]
```

---
##Adding elements to lists
- &lt;b&gt;list.insert(i, x)&lt;/b&gt; inserts x item at a postion i. All other elements at the index i and right from it are shifted to the right to create a space for the new item, so it is computionally expensive.


```python
my_list = [1, 2, 3, 4]
my_list.insert(1, 50)
my_list
# [1, 50, 2, 3, 4]
```
--
`list.insert(len(list), x)` is equivalent to `list.append(x)`

---
##Removing elements from lists
You can remove an element from a list either by specyfying its index or its value. 
- `pop()` method is is used to remove and return an element stored at the particular index.


```python
names_list = ['Alice', 'John', 'Bruce', 'Bob']
names_list.pop(0)
# 'Alice'
```


```python
names_list
# ['John', 'Bruce', 'Bob']
```
---
##Removing elements from lists
- `remove()` method is used to delete an element with the particular value.


```python
names_list = ['Alice', 'John', 'Bruce', 'Bob', 'Alice']
names_list.remove('Alice')
```


```python
names_list
# ['John', 'Bruce', 'Bob', 'Alice']
```
--
Note that only the first occurence of an element with a given value is removed and that `remove()` function does not return anything.

---
##Removing all elements of the list
`clear()` method removes all elements from the list.


```python
names_list = ['Alice', 'John', 'Bruce', 'Bob', 'Barbara']
names_list.clear()
names_list
# []
```

---
##Modifying elements of lists
Second thing that differentiates lists from tuples is that in case of lists you can change objects stored inside a list. You just need to specify the index of the object you want to change. All the slicing rules, that we have seen for tuples, also apply to lists.


```python
my_list = [1, 2, 3, 4]
my_list[1] = 10
my_list
# [1, 10, 3, 4]
```


```python
my_list[2:] = [20, 30]
my_list
# [1, 10, 20, 30]
```

---
##Sorting
Lists can also be sorted. You can use `sort()` method to do this.


```python
names_list = ['Alice', 'John', 'Bruce', 'Bob', 'Barbara']
names_list.sort()
names_list
# ['Alice', 'Barbara', 'Bob', 'Bruce', 'John']
```


```python
names_list.sort(reverse = True)
names_list
# ['John', 'Bruce', 'Bob', 'Barbara', 'Alice']
```

---
##Sorting
Note that sorting operation is done in in-place. This will therefore not work properly:


```python
names_list = ['Alice', 'John', 'Bruce', 'Bob', 'Barbara']
names_list = names_list.sort()
names_list
# 
```


```python
type(names_list)
# NoneType
```
---
##Sorting with key parameter
`sort()` can take a `key` argument in which you can specify a function that will produce a value that will be used for sorting.


```python
names_list = ['Alice', 'John', 'Bruce', 'Bob', 'Barbara']
names_list.sort(key = len)
names_list
# ['Bob', 'John', 'Alice', 'Bruce', 'Barbara']
```

---
##Reversing 
`reverse()` method reverses the order of objects in the list.


```python
names_list = ['Alice', 'John', 'Bruce', 'Bob', 'Barbara']
names_list.reverse()
names_list
# ['Barbara', 'Bob', 'Bruce', 'John', 'Alice']
```

---
##Copying list
`copy()` method is useful if you want to create the same list as the one that already exists in your environment.


```python
names_list = ['Alice', 'John', 'Bruce', 'Bob', 'Barbara']
names_list_2 = names_list
names_list.clear()
names_list_2
# []
```


```python
names_list = ['Alice', 'John', 'Bruce', 'Bob', 'Barbara']
names_list_2 = names_list.copy()
names_list.clear()
names_list_2
# ['Alice', 'John', 'Bruce', 'Bob', 'Barbara']
```

---
class: inverse, middle, center
#Common Sequence Operations

---
##Checking if the element is present in the sequence
You can check if a given element is present in a sequence list by using `in` operator. You can negate this statement using `not` operator.

.small-code[

```python
my_list = [1, 2, 3, 4, 5]
1 in my_list
# True
```


```python
1 not in my_list
# False
```


```python
's' in 'string'
# True
```
]
---
##Sequence concatenation
Two sequences can be merged into a one using `+` operation.


```python
[1, 2, 3] + [4, 5, 6] 
# [1, 2, 3, 4, 5, 6]
```


```python
'Alice' + ' has ' + 'a cat.'
# 'Alice has a cat.'
```


```python
(1, 2, 3) + (4, 5, 6)
# (1, 2, 3, 4, 5, 6)
```

---
##Repeating sequences
You can repeat a sequence using `*` operator and by specifying how many times a given sequence should be repeated.


```python
'Alice ' * 3
# 'Alice Alice Alice '
```


```python
[1, 2, 3] * 2
# [1, 2, 3, 1, 2, 3]
```

In the above example, you might have expected that numbers in the list will be multiplied, but the list is just repeated.

---
##Sequence functions and methods
There are a few dedicated functions and methods for sequences that are especially useful: 

--
- `len(s)`: returns length of the sequence s

.small-code[

```python
seq = [1, 2, 5, 2, 1]
len(seq) # 5
```
]

--

* `min(s)`/`max(s)`: returns smallest/largest item in the sequence s

.small-code[

```python
min(seq) # 1
max(seq) # 5
```
]
---
##Sequence functions and methods

- `s.index(x[, i[, j]])`: returns the lowest index of the object x in the sequence s (at or after index i and before index j)


```python
seq = [1, 2, 5, 2, 1]
seq.index(2) # 1
seq.index(2, 2) # 3
```

--
- `s.count(x)`: returns the number of occurrences of the object x in the sequence s


```python
seq.count(1)
# 2
```

---
class: inverse
###Exercise 3 (5 mins)
Find the largest value in the sequence below. How many times does it appear in the sequence? What is the index value of it's third appearance?


```python
vals = [1, 4, 14, 42, 31, 18, 17, 42, 35, 28, 18, 
        14, 16, 10, 42, 36, 14, 22, 13, 21, 24, 42]
```

???
max_val = max(vals)
number_of_appearances = vals.count(max_val)
first_index = vals.index(max(vals))
second_index = vals.index(max(vals), first_index + 1)
third_index = vals.index(max(vals), second_index + 1)
third_index

---
class: inverse, middle, center
#Dictionary

---
##Dictionary

- A dictionary is a collection of key-value pairs, where both the key and the value are Python objects.
- It has variable size.
- You can create it with curly braces, colons separate a key from value.


```python
my_dict = {'a': 1, 'b': 'string', 'c': [1, 2, 3]}
my_dict
# {'a': 1, 'b': 'string', 'c': [1, 2, 3]}
```

- key-value pairs in a dictionary are not in any specific order.

---
##Dictionary keys
`keys()` method returns the dictionary's keys.


```python
my_dict = {'a': 1, 'b': 'string', 'c': [1, 2, 3]}
my_dict.keys()
# dict_keys(['a', 'b', 'c'])
```

You can use it to check if the dictionary contains a given key.


```python
'a' in my_dict.keys()
# True
```

---
##Dictionary keys
Dictionary keys have to be an immutable object like scalar type (int, float, string) or a tuple, that consists of immutable items itself.


```python
my_dict = {[1,2]: 'a'}
# TypeError: unhashable type: 'list'
```


```python
my_dict = {(1,2): 'a'}
my_dict
# {(1, 2): 'a'}
```


```python
my_dict[(1, 2)]
# 'a'
```
---
##Dictionary values
A dictionary value can be any Python object. `values()` method returns values stored in the dictionary.


```python
my_dict = {'a': 1, 'b': 'string', 'c': [1, 2, 3]}
my_dict.values()
# dict_values([1, 'string', [1, 2, 3]])
```

---
##Dictionary values
You can access specific value in the dictionary using square brackets, but instead of the index you need to specify the key of a given object.


```python
my_dict = {'a': 1, 'b': 'string', 'c': [1, 2, 3]}
my_dict['a']
# 1
```


```python
my_dict['b']
# 'string'
```


```python
my_dict['c']
# [1, 2, 3]
```
---
##Dictionary keys and values
Sometimes it is also useful to access both keys and values of the dictionary at the same time. This is when `items()` method comes into play. It returns a list with `(key, value)` tuples.


```python
my_dict = {'a': 1, 'b': 'string', 'c': [1, 2, 3]}
my_dict.items()
# dict_items([('a', 1), ('b', 'string'), ('c', [1, 2, 3])])
```
---
##Adding values to a dictionary
You can add a new key-value pair to the dictionary by specifying a new key and assigning a value to it.

.small-code[

```python
my_dict = {'a': 1, 'b': 'string', 'c': [1, 2, 3]}
my_dict[10] = (5, 6, 7)
my_dict
# {'a': 1, 'b': 'string', 'c': [1, 2, 3], 10: (5, 6, 7)}
```
]
--
If you use the key that is already in the dictionary, you will change the element that is stored under this key.

.small-code[

```python
my_dict['b'] = 'another_string'
my_dict
# {'a': 1, 'b': 'another_string', 'c': [1, 2, 3], 10: (5, 6, 7)}
```
]
---
##Removing values from a dictionary
You can remove key-value pair using `del` keyword or `pop()` method.

.small-code[

```python
my_dict = {'a': 1, 'b': 'string', 'c': [1, 2, 3], 10: (5, 6, 7)}
del my_dict[10]
my_dict
# {'a': 1, 'b': 'string', 'c': [1, 2, 3]}
```
]

--
.small-code[

```python
a_element = my_dict.pop('a')
my_dict
# {'b': 'string', 'c': [1, 2, 3]}
```
]

--

The difference between those two approaches is that `pop()` returns the value that corresponds to the key that is being removed, so you can assign it to a variable.

---
class: inverse
###Exercise 4 (5 min)
You store Python packages and their versions that you use in the dictionary. 


```python
my_packages = {'numpy': 1.12, 'pandas': 0.23, 
               'sqlalchemy': 1.2, 'theano': 1.0}
```

Recently you made some changes. Update your dictionary to keep it up-to-date.

1. You update numpy package to the version 1.15. Change the version of this package in you dictionary.
2. After a workshop, during which you became a master of creating plots in Python, you decide to start using matplotlib in your project.  Add it to you dictionary with the version 3.0.
3. As you learn that theano module will no longer be developed, you decide to stop using it in your project. Remove it from your dictionary.


???
my_packages['numpy'] = 1.15
my_packages['matplotlib'] = 3.0
del my_packages['theano']
my_packages

---
##Merging dictionaries
`update()` function can be used to merge one dictionary into another.


```python
my_dict = {'a': 1, 'b': 'string', 'c': [1, 2, 3]}
my_dict_2 = {'a': 4, 'd': 'string_2'}
my_dict.update(my_dict_2)
my_dict
# {'a': 4, 'b': 'string', 'c': [1, 2, 3], 'd': 'string_2'}
```

--
If keys are the same in both dictionaries their values in the first dictionary will be overwritten, so you can use this method to update values in your dictionary.

---
class: inverse, middle, center
#Set

---
##Set
- Set is an unordered collection of unique, immutable elements.
- It can be created using curly brackets or using the `set()` function.


```python
set([10, 20, 10, 18, 10, 15])
# {10, 15, 18, 20}
```


```python
{10, 20, 10, 18, 10, 15}
# {10, 15, 18, 20}
```

Notice that set keeps only unique values from the sequence.

---
##Set operations
The main advantage of sets is that they support mathematical set operations.

.small-code[

```python
a = {1, 2, 3, 4, 5}; b = {3, 4, 5, 6, 7}
```
]

--

+ `set.union()` returns unique elements in a and b:

.small-code[

```python
a.union(b)
# {1, 2, 3, 4, 5, 6, 7}
```
]

--

+ `set.intersection()` returns unique elements that are both in a and b:

.small-code[

```python
a.intersection(b)
# {3, 4, 5}
```
]

---
##Set operations
+ `set.difference()` returns unique elements that are in a but not in  b:

.small-code[

```python
a = {1, 2, 3, 4, 5}; b = {3, 4, 5, 6, 7}
a.difference(b)
# {1, 2}
```
]

--

+ `set.issubset()` checks if all elements from a are in b:

.small-code[

```python
a = {1, 2, 3}; b = {1, 2, 3, 6, 7}
a.issubset(b)
# True
```


```python
b.issuperset(a) # similar but from perspective of b
# True
```
]
---
class: inverse
###Exercise 5 (5 min)
You will be working with your colleague, Anna, on your next project. She sends you her list of packages to make sure that you have them all. Based on her list and your own, check what packages you already have, and which ones you need to install.


```python
anna_packages = ['tensorflow', 'keras', 'matplotlib', 
                 'seaborn', 'pandas', 'numpy']
my_packages = ['scikit-learn', 'numpy', 'pandas', 'bokeh']
```

???
anna_packages = set(anna_packages)
my_packages = set(my_packages)
anna_packages.intersection(my_packages)
anna_packages.difference(my_packages)

---
class: inverse, bottom, center
background-image: url('www/img/logo_white.png')
background-size: 50%

mb@idash.pl mo@idash.pl
    </textarea>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"ratio": "16:9",
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function() {
  var d = document, s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})();</script>

<script>
(function() {
  var i, text, code, codes = document.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
})();
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
