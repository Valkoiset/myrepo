<!DOCTYPE html>
<html>
  <head>
    <title>Functions and exceptions handling</title>
    <meta charset="utf-8">
    <meta name="author" content="Mercer 2018" />
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link rel="stylesheet" href="css\idash.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Functions and exceptions handling
### Mercer 2018

---


class: inverse, center, middle

# Functions
---


## Types of functions

- built-in functions,
- user defined functions,
- anonymous functions (lambdas).

---

## Built-in functions

The Python interpreter has a number of functions and types built into it that are always available.


```python
x = [1, 2, 3]
sum(x)
```

--

```python
print(sum.__class__)
# &lt;class 'builtin_function_or_method'&gt;
```
---
## Accessing function's documentation
You can access the function's documentation using `__doc__` attribute...


```python
print(sum.__doc__)
```

--
...or use built-in `help()` function get more information.

```python
help(sum)
```

---
 ## User defined functions

 Recipe for a function:
 1. Start with keyword `def`.
 2. Specify __function's name__.
 3. Add __parameters__ (they should be within the parentheses).
 4. End first line with `:`.
 5. Add __statements__ that the function should execute.
 6. End your function with a `return` statement if the function should output something. Without the return statement, your function will return an object None.

--

```python
def name_of_the_function(parameter_1, parameter_2):
    # things for function to do
    return parameter1
```

---
## Functions vs Methods

A __method__ refers to a function which __is part of a given class__. You access it with an instance of this class. A function doesn't have this restriction, it is __standalone__. This means that __all methods are functions but not all functions are methods__.

--


```python
def func_sum_elements(element1, element2):
    return element1 + element2
func_sum_elements(1, 3)
# 4
```


---
## Functions vs Methods

```python
class MathOperations():
    def math_sum_elements(self, element1, element2):
        return element1 + element2
math_sum_elements(1, 3)
# This will throw NameError
```
 
--

```python
instance_of_math = MathOperations()
instance_of_math
# &lt;__main__.MathOperations at 0x2038e6789e8&gt;
```

--

```python
instance_of_math.math_sum_elements(1, 3)
# 4
```

---
## Parameters vs Arguments

__Parameters__ are the names __used when defining a function or a method__, and into which arguments will be mapped. 

__Arguments__ are the things which are __supplied to any function or method call__.

A function refers to arguments by their parameter names.

---
## Parameters vs Arguments

```python
def func_sum_elements(element1, element2):
    return element1 + element2
```

--
Element1 and element2 are __parameters__ in the function definition.

--

```python
func_sum_elements(1, 3)
```

--
During function call __arguments__ 1 and 3 are mapped onto the parameters element1 and element2 by position. &lt;br&gt;&lt;br&gt;

---
## Parameters vs Arguments
An alternative is keyword mapping, where we explicitly state which argument maps to which parameter.


```python
func_sum_elements(element2=3, element1=4)
```

---
## Returning a value from a function

You need to use the `return` statement to return a value as an output of the function.

--


```python
def empty_func():
    1
empty_func()
# 
x = empty_func()
x is None
# True
```

---
## Returning a value from a function

```python
def proper_func():
    return 1
proper_func()
# 1
x = proper_func()
x is None
# False
```

---
## Returning a value from a function
Functions immediately exit when they come across a `return` statement.
--

.small-code[

```python
def my_func(x, y):
    if x &gt; 1:
        return x
    print("I failed conditional statement")
    return x + y
my_func(1, 6)
# I failed conditional statement
# 7
my_func(4, 3)
# 4
```
]

---
## Returning multiple values from a function
Function can return multiple values, which are packed into `tuple` under the hood.


```python
def multiply_by_two(x, y):
    return x * 2, y * 2
multiply_by_two(2, 5)
# (4, 10)
type(multiply_by_two(2, 5))
# tuple
```

---
class:inverse
### Exercise 1 (10 min)
You are given a two-digit integer n. Write a function that returns the sum of its digits. 

Example: n = 31, result = 4

???
def add_two_digits(n):
    return n//10 + n%10

---
## Default values
When defining a function, you can specify default values of parameters. Those values are used when the corresponding argument is not passed during the function call. 

--


```python
def my_func(x = 'this is default value'):
    return x
my_func('abc')
# abc
my_func()
#  this is default value
```
---
class:inverse
### Exercise 2 (3 min)
 
Write a hello function with one parameter - name. When the argument is passed it greets the person by name. If not, it greets the world.
 
???
def hello(name='world'):
    print(f'hello {name}!')

---
## args

Let's say we want to create a function that sums integers. If we write it this way:

.small-code[

```python
def sum_elements(x, y):
    return x + y
```
]
--
It will work fine for two arguments:

.small-code[

```python
sum_elements(1, 3)
# 4
```
]
--
But it will throw the error if we pass three arguments:

.small-code[

```python
sum_elements(1, 3, 5)
# TypeError: sum_elements() takes 2 positional arguments but 3 were given
```
]
---
## args
We could extend our function to accept three arguments:

--
.small-code[

```python
def sum_elements(x, y, z):
    return x + y + z
sum_elements(1, 3, 5)
# 9
```
]

--
But yet again we will face problems when a user will pass more arguments:

.small-code[

```python
sum_elements(1, 3, 5, 2)
# TypeError: sum_elements() takes 3 positional arguments but 4 were given
```
]

---
## args
The way around this problems is using `*args`:

--

```python
def sum_elements(*args):
    result = 0
    for element in args:
        result += element
    return result
```

--

```python
sum_elements(1, 3, 5, 2)
# 11
sum_elements(1, 3, 5, 2, 7, 2, 6)
# 26
sum_elements(1, 3, 5, 2, 7, 2, 6, 10, 1, 5, 7)
# 49
```

---
## args
`*args` work as a tuple, which is created on a fly from arguments passed to the function. We can use it in function definition and reference to it later by name as an ordinary tuple. You can call `args` whatever you want, what is important is a `*` notation.

--

```python
def sum_elements(*elements):
    print(elements)
    print(type(elements))
    
sum_elements(1, 3, 5, 2, 7, 2, 6, 10, 1, 5, 7)
# (1, 3, 5, 2, 7, 2, 6, 10, 1, 5, 7)
# &lt;class 'tuple'&gt;
```
 
---
## kwargs
`**kwargs` (keyword arguments) work in similar fashion to `*args` but have a dictionary structure. Similarly, the name is not relevant here, what matters is ** notation.

.small-code[

```python
def get_shopping_list(**kwargs):
    for key, value in kwargs.items():
        print(f'Buy {value} {key}')
```
 

```python
get_shopping_list(apples = 3, tomatoes = 6)
# Buy 3 apples
# Buy 6 tomatoes
```


```python
get_shopping_list(apples = 3, tomatoes = 6, ham = 1)
# Buy 3 apples
# Buy 6 tomatoes
# Buy 1 ham
```
]
---
## Args in function calls

You can use `*args` in a function call as a way to unpack arguments from list or tuple.
.small-code[

```python
def my_function(param_1, param_2):
    return f'Your param_1 = {param_1} and param_2 = {param_2}'
```


```python
args = 1, 2
my_function(*args)
# 'Your param_1 = 1 and param_2 = 2'
```
]

---
## Args in function calls
Arguments will be mapped on parameters based on their positions, therefore order matters.

--
.small-code[

```python
args = 2, 1
my_function(*args)
#'Your param_1 = 2 and param_2 = 1'
```
]
---
## Kwargs in function calls
`**kwargs` can be used to unpack arguments from the dictionary. In this case, arguments will be mapped by respective key's therefore the order of elements in dictionary does not matter.

--

```python
kwargs = {'param_1': 1, 'param_2': 2}
my_function(**kwargs)
# 'Your param_1 = 1 and param_2 = 2'
```

--

```python
kwargs = {'param_2': 2, 'param_1': 1}
my_function(**kwargs)
# 'Your param_1 = 1 and param_2 = 2'
```

---
## Order of arguments when creating a function
When ordering arguments during a function construction, they need to occur in a particular order:
 
 1. Formal positional arguments
 2. *args
 3. Keyword arguments
 4. **kwargs

--

.small-code[

```python
def fn(a, b, *args, e = 1, **kwargs):
        print(a)
        print(b)
        print(args)
        print(e)
        print(kwargs)
fn(1, 2, 3, 4, 5, e = 6, f = 7, g = 8)
```
]

---
## Order of arguments when calling a function
When calling a function you need to specify positional arguments or `*args` first, and then keyword arguments or `*kwargs`.

.small-code[

```python
def my_func(param_1, param_2, param_3, param_4, param_5, param_6):
        print(f'param_1 = {param_1}')
        print(f'param_2 = {param_2}')
        print(f'param_3 = {param_3}')
        print(f'param_4 = {param_4}')
        print(f'param_5 = {param_5}')
        print(f'param_6 = {param_6}')
```
]

.small-code[

```python
args = [2, 3]
kwargs = {'param_5': 5, 'param_6': 6}
my_func(1, *args, param_4=4, **kwargs)
```
]

---
## Order of arguments when calling a function
We can mix positional arguments and `*args` on one hand, and keyword arguments and `**kwargs` on other.

.small-code[

```python
args = [2, 3]
kwargs = {'param_5': 5, 'param_6': 6}
my_func(*args, 1, **kwargs, param_4=4)
#param_1 = 2
#param_2 = 3
#param_3 = 1
#param_4 = 4
#param_5 = 5
#param_6 = 6
```
]

---
## Order of arguments when calling a function
However, keyword arguments can never precede positional arguments.

`my_func(*args, **kwargs, 1, param_4=4)`

Will result in `SyntaxError: positional argument follow keyword argument unpacking.`

---
class: inverse
### Exercise 3 (5 min)
 
Make your own implementation of `dict()` function.


```python
my_dict(a = 1, b = 2, c = 3)
# {'a': 1, 'b': 2, 'c': 3}
```

???
def my_dict(**kwargs):
        return kwargs

---
## Anonymus functions (lambda functions)
__Lambda expressions__ are a __special syntax__ for __making functions__. They can only have __one statement__ in them and they return the result of that statement __automatically__. They are used for functions that are only used in __one place__ and do just __one thing__.

--


```python
(lambda x: x ** 2)(2)
# 4
```

--

```python
(lambda x, y: x ** 2 + y ** 2)(3, 4)
# 25
```

---
## Lambda functions
 This syntax is equivalent of declaring a function with `def`, just written inline. The difference is that you don't have to bind it to a name before using it. You can simply state the expression you want to compute and then immediately evaluate it by calling it like a regular function. Technically you can also write it as below:

 
--

```python
sum_squared_lambda = lambda x, y: x ** 2 + y ** 2
```

 
--

```python
sum_squared_lambda(3, 4)
# 25
```

--
But the above code ignores the reason why `lambda` functions are useful. That is, `lambda` functions are to passed around without being assigned to a variable.

---
## Lambda functions
In case you want to name your function it is better to write it following way:

--

```python
def sum_squared_fun(x, y): return x ** 2 + y ** 2
```

--
as it makes it easier for debugging:
--

```python
sum_squared_lambda
# &lt;function __main__.&lt;lambda&gt;(x, y)&gt;
sum_squared_fun
# &lt;function __main__.sum_squared_fun(x, y)&gt;
```

--
Unlike functions defined with `def`, `lambda` functions __never have a name__ (it's always just lambda).

---
class: inverse, center, middle
# Lambda use cases

---
## Lambda as the sorting key
Any time you're expected to supply a function object you can use a `lambda` expression. 

Most frequent use case for `lambdas` is writing a short and concise key function for sorting iterables by an alternative key:

--

```python
sorted(range(-5, 6), key = lambda x: x ** 2)
# [0, -1, 1, -2, 2, -3, 3, -4, 4, -5, 5]
```

---
## Lambda in `map()` and `filter()`
You can also use lambdas when you want to apply a function to every element of a sequence using `map()` function:


```python
list(map(lambda x: x * 2, range(1, 5)))
# [2, 4, 6, 8]
```

--
Or as a filtering condition in `filter()` function:

--

```python
list(filter(lambda x: x % 3 == 0, range(16)))
# [0, 3, 6, 9, 12, 15]
```

Note that lambda needs to return boolean value here.

---
## Lambda in `reduce()`
You can also use a lambda in `reduce` to cumulatively apply function to iterable, from left to right and reduce the sequence to a single value:

--

```python
from functools import reduce
reduce(lambda x,  y: x + y, range(1, 5))
# 10 
```

---
## Lambda vs list comprehension
Nevertheless, `list comprehension` is usually easier to understand. Consider the first two examples from previous slide and their equivalents rewritten as list comprehension statements.

 
--

```python
list(map(lambda x: x * 2, range(1, 5)))
[n * 2 for n in range(1,5)]
```

--

```python
list(filter(lambda x: x % 3 == 0, range(16)))
[x for x in range(16) if x % 3 == 0]
```

---
class:inverse
### Exercise 4 (10 min)
 
Sort the list below by the number of letters 'a' in each word in descending order.

```python
l = ['head', 'laboratory', 'key', 'aardvark']
```

???
sorted(l, key=lambda x: x.count('a'), reverse=True)

---
##Things to remember:
 1. `Lambdas` can be immediately passed around (no variable needed).
 2. They can only have a single line of code within them.
 3. They `return` automatically.
 4. They can sometimes be hard to understand and debug, therefore should be used sparsely.
---
class: inverse, middle, center

#Handling exceptions

---
##Types of errors
There are two types of errors in Python:
- &lt;b&gt;Syntax errors&lt;/b&gt; result from incorrect syntax (e.g. misspelling of a function name, wrong indentation, missing parenthesis)
- &lt;b&gt;Exceptions&lt;/b&gt; happen when a syntactically correct code results in an error (e.g. division by zero)


```python
2 / 0
# ZeroDivisionError: division by zero
```

---
##Error handling
Both types of errors lead to the termination of a Python code. But there are differences in the way we can handle them. Although syntax errors need to be removed from the code before it is executed, exceptions can be handled programmatically using a special construction called &lt;b&gt;try and except block&lt;/b&gt;. 

---
##Try and except block

```
try:
    do this operation, up to the point when an error is raised
except:
    execute this code if an exception is raised
else:
    execute this code if there is no exception
finally:
    execute this code no matter what
```
---
##`try` block contains the code that we want to execute


```python
try:
    2 / 1
except:
    print('The code encountered an exception.')
else:
    print('There was no error.')
finally:
    print('End')
# 1
# There was no error.
# End
```
---
##`except` clause is executed if the code encounters an exception


```python
try:
    2 / 0
except:
    print('The code encountered an exception.')
else:
    print('There was no error.')
finally:
    print('End')
# The code encountered an exception.
# End
```

---
##`else` clause is executed if there are no exceptions


```python
try:
    2 / 1
except:
    print('The code encountered an exception.')
else:
    print('There was no error.')
finally:
    print('End')
# There was no error.
# End
```

---
##`finally` clause will be executed no matter what happens


```python
try:
    2 / 0
finally:
    print('End')
# End
# ZeroDivisionError: division by zero
```

---
##Handling specific exceptions
It is a good programming practice to specify the type of error that is to be handled by our code, because general except clauses may react to errors that we are not even aware of, and that should be dealt with differently. We can do this by adding the type of an error next to `except` clause.

---
##Handling specific exceptions

```python
try:
    2 / 0
except ZeroDivisionError:
    print('The code encountered zero division error.')
else:
    print('There was no error')
finally:
    print('End')
# The code encountered zero division error.
# End
```

---
##`except` clause with specific exceptions will only react to those exceptions


```python
try:
    2 / 'b'
except ZeroDivisionError:
    print('The code encountered zero division error.')
else:
    print('There was no error')
finally:
    print('End')
# End
# TypeError: unsupported operand type(s) for /: 'int' and 'str'
```
---
##We can specify several exceptions to be handled


```python
try:
    2 / 'b'
except ZeroDivisionError:
    print('The code encountered zero division error')
except TypeError:
    print('The code encountered type error.')
else:
    print('There was no error')
finally:
    print('End')
# The code encountered type error.
# End
```

---
##Exception can be saved in a variable
.small-code[

```python
try:
    2 / 'b'
except ZeroDivisionError as error:
    print(f'The code encountered following error: {error}')
except TypeError as error:
    print(f'The code encountered following error: {error}')
else:
    print('There was no error')
finally:
    print('End')
# The code encountered following error: unsupported operand type(s) for /: 'int' and 'str'
# End
```
]
---
class: inverse
###Exercise 5 (5 min)
You have written the function that counts the number of occurrences of 'a' letter in a given string. Using exception handling make it print 'Not a string' when a user inputs something different than a string.


```python
def count_a(string):
    return string.count('a')
```

???
def count_a_mod(string):
    try:
        return string.count('a')
    except AttributeError:
        print('Not a string')
count_a(1)

---
##Raising your own exceptions
You can also raise your own exception when the specific condition is met, and influence the code execution this way.


```python
import math
def square_even(num):
    if num % 2 != 0:
        raise ValueError('Provided number should be even')
    return math.sqrt(num)
square_even(3)    
# ValueError: Provided number should be even
```

---
class: inverse
###Exercise 6 (5 min)
Add the code to the function from the previous exercise that will raise a ValueError if a user provides an empty string.

???
def count_a_mod(string):
    if string == '':
        raise ValueError("Provided string is empty.")
    try:
        return string.count('a')
    except AttributeError:
        print('Not a string')
count_a_mod('')

---
##Assert statement
It is a very good programming practice, to test your code as you write it. `assert` statement is useful for that.
It is sometimes placed at the start of the function to check if the input is as expected, and after the function call to check if an output is valid. 

If the condition that you specify in assert statement is not met it will raise AssertionError.

---
##Using `assert` to check the input


```python
def multiply_by_itself(a):
    assert isinstance(a, (int, float)), 'Not a numeric type'
    return a * a
```


```python
multiply_by_itself(1)
# 1
```


```python
multiply_by_itself('a')
# AssertionError: Not a numeric type
```
---
##Using `assert` to test a function


```python
def multiply_by_itself(a):
    try:
        return a * a
    except TypeError:
        return a
```


```python
assert multiply_by_itself(1) == 1
assert multiply_by_itself(2) == 4
assert multiply_by_itself('a') == 'a'
```

---
##Key takeaways:
- You can use &lt;b&gt;try and except block&lt;/b&gt; to handle exceptions. It consists of several parts:
    - `try` contains the actual code that we want to run, it is executed normally until the exception is encountered,
    - `except` clause is executed when an exception is encountered in try clause. You should try to avoid general except clauses, by naming exception you want to handle.
    - `else` code is executed when there were no exceptions in the try block, 
    - `finally` code is executed no matter what. It is worth to put here mission-critical code, like shutting down virtual machines that you pay for a minute.
---
#Summary
- You can raise your own exceptions using `raise` clause.
- `assert` allows you to test your code.

---
class: inverse, bottom, center
background-image: url('www/img/logo_white.png')
background-size: 50%

mb@idash.pl mo@idash.pl
    </textarea>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"ratio": "16:9",
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function() {
  var d = document, s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})();</script>

<script>
(function() {
  var i, text, code, codes = document.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
})();
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
